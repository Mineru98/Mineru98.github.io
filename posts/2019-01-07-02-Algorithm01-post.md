# 개요
컴공(컴퓨터공학과) 관련 된 학과를 나왔다면 다들 한번씩 들어봤던 과목이다.
설령 컴공을 나오지 않더라도 다양한 매체를 통해서 `알고리즘`이란 말을 자주 언급되어서
다들 알고 있는 키워드이다.

![그림1: 알고리즘](https://d81pi4yofp37g.cloudfront.net/wp-content/uploads/algorith.png)

그런데 정말 알고리즘은 무엇일까?

# 알고리즘이란?
> [어떤 문제를 해결하기 위한 절차, 방법, 명령어들의 집합.](https://terms.naver.com/entry.nhn?docId=3597402&cid=58598&categoryId=59316)

프로그래밍에서는 더 구체적으로 설명을 해야할 필요가 있다.

> 어떤 문제를 컴퓨터를 사용해서 해결하기 위한 절차나 방법

이를 글쓰기 방법으로 예를 들어보겠다.
글쓰기에는 다양한 방법이 존재한다.
연필로 글쓰기, 볼펜으로 글쓰기, 노트북으로 글쓰기, 크레파스로 글쓰기
다양한 글쓰기 방법이 있지만 글의 목적에 따라서 사용하는 도구가 달라진다.
그리고 자신의 편리함에 따라서 사용하는 도구가 달라지기도 한다.

이처럼 정해진 답을 찾아가는 것이 아니라,
자신의 상황에 따라 행동하여 답을 찾아내는 것이 알고리즘이다.

---------------------------------------

# 알고리즘의 조건
1. 입력
어떠한 질문에 대답을 하기 위해서는 질문이 있어야 하는 것처럼
입력은 질문에 해당하는 부분이라고 할 수 있다.
2. 출력
질문에 대한 대답이라고 할 수 있는 부분이라고 할 수 있습니다.
3. 명확성
질문의 요지를 정확하게 파악하기 위해서는 질문의 문장을 하나하나를
부분으로 나누어 분석을 합니다. 명확성이란, 이런 질문에 대한 문장을
얼마나 잘게 눴는지를 말합니다.
4. 유한성
일반적으로 질문에 대한 대답은 할 수가 있지만
시간적문제로 인해 바로 모든 대답을 할 수 없는 경우도 생길 수 있다.
그래서 일반적으로 시간 혹은 메모리에 대한 제한을 두고 이 조건 안에
해결 할 수 없는 문제는 해결하지 못한다고 판단한다.
5. 효율성
알고리즘에서 가장 중요한 핵심이라고 할 수 있다.
알고리즘은 효율이란 말로 시작해서 효율이란 말로 끝난다.
문제를 해결하는 방법의 답은 없지만 우리는 문제를 완벽하게
해결하면서 가장 빠르게 해결한 방법을 좋다고 평가한다.
따라서 알고리즘에서는 이러한 효율성을 측정할 수 있어야 한다.

---------------------------------------

# 알고리즘은 왜 평가해야 할까?
알고리즘의 조건을 말하면서 강조한 것은 효율성이다.
효율성이란 것은 하나의 기준점과 다른 하나와 비교를 할 수 있어야 한다.
따라서 누가 더 효율적인지를 설명하기 위해서는 기준이 있어야 한다.
주어진 상황에 더 적합한 해결 방법이 무엇인지 가려야하는 상황에
일일이 실행착오를 겪으면서 결정하는 것보다는
어떠한 대략적인 기준점이 있으면 보다 빠르게 결정을 할 수 있을 것이다.
그래서 알고리즘을 평가하는 기준이 필요한 것이다.

---------------------------------------

# 알고리즘 평가의 세가지 요소
* 시간의 효율성
  * 코드로 설명을 해보겠다.
    ```python
    data = []
    for i in list(range(1,1001)):
        data.append(i)

    num = int(input("찾을 값을 입력하세요 => "))

    for i in list(range(0,1000)):
        if(num == data[i]):
            print("찾으려고 하는 값의 배열 data의 ",i,"번째에 있습니다.");
            break
    ```

    위 코드는 최악의 경우에는 1000번의 연산을 다 해야만 결과를 알 수 있다.

    ```python
    data = []
    min = int(1)
    max = int(1000)
    for i in list(range(1,1001)):
        data.append(i)

    num = int(input("찾을 값을 입력하세요 => "))

    i = int((max + min) / 2.0)

    while min<max:
        if(num == data[i]):
            print("찾으려고 하는 값의 배열 data의 ",i,"번째에 있습니다.");
            break
        elif(num < data[i]):
            max = max - int((max - min) / 2.0)
        else:
            min = min + int((max - min) / 2.0)
        i = min + int((max - min) / 2.0)
    ```
    위 코드는 최악의 경우라도 9번만에 찾아낼 수 있다.

    이러하듯 시간 효율성을 대단히 중요한 점이다.
* 공간의 효율성
  * 불필요한 변수 선언은 최대한 줄이는 것이 공간 효율성을 말한다.
    예를 들면 특정 함수에서만 사용하는 변수는 해당 변수의 지역에서만 선언하고
    사용하면 되는데 자기 편하자고 전역변수로 선언해두고 사용하는 것은
    알고리즘 성능에 영향을 미친다. 낭비되는 메모리가 없도록 주의하며 코드를 작성해야한다.
* 코드의 효율성
  * 코드의 효율성에는 두가지 측면이 있다.
    프로그래머 입장에서의 효율적인 코드와 컴퓨터 입장에서의 효율적인 코드.
    첫번째, 프로그래머 입장에서의 효율적인 코드는 가독성이 뛰어난 코드를 말한다.
    혼자서 진행하는 프로젝트이며 이후 다른 사람이 수정할 필요가 없는 경우라면
    굳이 가독성을 뛰어나게 작성할 필요는 없지만 협업을 해야하는 입장에서는
    가독성이 뛰어나게 작성하는 편이 좋다. 또한 다른 사람에게 알고리즘에 대해서
    설명을 하기 위해서는 아무래도 가독성이 좋은 코드를 작성하면 상대가 이해하기 쉬울 것이다.
    두번째, 컴퓨터 입장에서의 효율적인 코드는 실제 작동이 더 빠른 코드를 말한다.
    협업을 하는 동안에는 이런 코드를 작성을 하면 상대가 이해력이 좋은 사람이
    아니라면 코드를 빠르게 이해하기 어려울 것이다.

---------------------------------------

자, 그럼 알고리즘의 성능을 평가해야하는 이유와 조건들을 알아보았으니
평가하는 방법에 대해서 알아보겠다.

# 알고리즘의 성능 표기법
알고리즘 성능 표기법에는 총 세가지 방법이 있다.
* 오메가(Ω) 표기법
* 세타(Φ) 표기법
* 빅오(Ο) 표기법

오메가(Ω) 표기법은 컴퓨터의 성능이 최고인 경우에 사용하는 표기법이다.
자주 사용하지 않는다고 한다.
세타(Φ) 표기법은 컴퓨터의 성능이 최고도 최악도 아닌 경우에 사용하는 표기법이다.
컴퓨터 성능의 평균적인 값이다 보니 자주 사용될 것 같지만 실제로 이러한 방식으로는
성능을 표기하기 어렵다고 한다.
마지막으로 빅오(Ο) 표기법은 가장 많이도 아니고, 거의 90%는 이 표기법을 사용한다.

다음 코드를 가지고 알고리즘 분석을 해보도록 하겠다.
```python
sum = int(0)
for i in list(range(1,101)):
    sum = sum + i

print("1부터 100까지의 합은  : ",sum)
```

| 알고리즘 성능에 영향을 주는 코드 | 실행 횟수 |
|:--------|:--------:|
| sum = int(0) | 1회 |
| for i in list(range(1,101)): | 101회 |
| sum = sum + i | 100회 |
| print("1부터 100까지의 합은  : ",sum) | 1회 |
| 합계 | 203회 |

빅오 표기법으로 작성하자면 `Ο(203) = Ο(1)`이 된다.
203이라는 상수는 실제로 알고리즘의 성능에는 아무런 영향을 주지 못하기 때문에
1와 같은 성능으로 취급합니다.

# 빅오 표기법의 종류
![그림2: 알고리즘 성능 그래프](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F22158A4F565E7A6219ACF4)

* Ο(1)
  처리해야 할 데이터의 양과 상관없이 항상 일정한 실행 시간을 갖는 알고리즘이다.
  대표적으로 Hash Table이 있다.
* Ο(logN)
  처리해야 할 데이터의 양이 많아질수록 실행 시간도 조금씩 증가하는 알고리즘이다.
  대표적으로 Binary Search가 있다.
* Ο(N)
  데이터의 양과 실행 시간이 비례하는 알고리즘이다.
  대표적으로 Linear Search, Linked List가 있다.
* Ο(NlogN)
  처리해야 할 데이터의 양보다 실행 시간이 더 빠르게 증가하는 알고리즘이다.
  대표적으로 Quick Sort, Merge Sort가 있다.
* Ο(N²)
  ```python
  for i in N:
    for j in N:
      #처리
  ```
  위 코드와 같은 경우의 알고리즘 성능 표기이다.
  이중 중첩 for을 사용한 경우이며
  대표적으로 Bubble Sort, Insert Sort가 있다.
* Ο(N³)
  Ο(N²)와 같은 개념으로 다른 점은 삼중 중첩 for을 사용한 경우이다.
  대표적으로 Matrix Multiplication
* Ο(2^N)
  작성해서는 안되는 알고리즘이라는 평가를 받는다.

---------------------------------------

# 결론
알고리즘에는 정답이란 것이 존재하지 않는다.
단지 현재 상황에 가장 적절한 알고리즘을 선택하여 최종적으로 문제를 해결하면 되는 것이다.
그래서 세상 모든 일들은 알고리즘으로 이루워져있으며, 해결할 수 없는 문제는 없다.
그저 효율적이거나 현실적인 방법을 아직 찾아내지 못했을 뿐...
