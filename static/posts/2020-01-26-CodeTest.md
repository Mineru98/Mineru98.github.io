## 나는 왜 테스트 코드를 작성하지 않았는가...

나는 아직 이해가 되지 않는다. 왜 테스트 코드를 작성해야 하는지를 좀 더 와 닿게 설명을 해놓은 글이나 이야기를 들은 적이 없다. 테스트 코드 작성을 강조하지만 왜 해야하는지 구체적인 이유를 언급을 못하는 이유가 뭘까? 뚜렷한 이유를 제시를 나에게 제시하지 않고선 쉽게 나의 현재 생각을 바꾸긴 어려울 것 같다.

그렇다고 안 할 순 없을 것 같단 생각이 든다. 왜냐하면, 내가 테스트 코드를 작성하지 않는 이유를 잘 생각해보면 나도 마찬가지로 근거가 부족하다. 내가 테스트 코드를 작성하지 않는 첫 번째 이유는 귀찮다는 것이다. 듣는 사람 입장선 정말 어이가 없겠지만, 테스트 코드를 작성할 이유를 모르다 보니 굳이 하고 싶지도 않고 그러다 보니 하려고 하면 귀찮을 뿐이다.

그리고 과거에 내가 하기 싫다고 하지 않다고 인제 와서 절실히 필요한 것들이 몇 가지 있었다. 그런 경험을 생각하면 테스트 코드 작성은 분명 미래의 나에게 도움이 되는 일이라 생각한다.

## 테스트 코드 작성 원칙

테스트 코드 작성에는 원칙이 있다.

- 테스트 유닛은 각 기능의 가장 작은 단위에 집중하여, 해당 기능이 정확히 동작하는지를 증명해야 한다.

- 각 테스트 유닛은 반드시 독립적이어야 한다. 각 테스트는 혼자서도 실행 가능해야 하고, 테스트 슈트로도 실행 가능해야 한다. 이때, 호출되는 순서와 무관하게 잘 동작해야 한다.

- 테스트가 빠르게 돌 수 있게 하기 위해 노력해야 한다. 테스트 하나가 실행하는데 몇 밀리 세컨드 이상의 시간이 걸린다면, 개발 속도가 느려지거나 테스트가 충분히 자주 수행되지 못할 거다. 테스트에 필요한 데이터 구조가 너무 복잡하고, 테스트하려면 매번 이 복잡한 데이터를 불러와야 해서 테스트를 빠르게 만들 수 없는 예도 있다. 이럴 때는 무거운 테스트는 따로 분리하여 별도의 테스트 슈트를 만들어 두고 일정 작업을 걸어두면 된다.

- 지금 사용하고 있는 도구가 개별 테스트나 테스트 케이스를 어떻게 수행하는지 배우셔야 한다. 모듈 안에 들어있는 함수를 개발하고 있다면, 그 함수의 테스트를 자주, 가능하다면 코드를 저장할 때마다 자동으로 돌려야 한다.

- 그날의 코딩을 시작하기 전에 항상 풀 테스트 슈트를 돌려야 한다. 끝난 후에도 마찬가지다.

- 모두가 공유하는 저장소에다가 코드를 집어넣기 전에 자동으로 모든 테스트를 수행하도록 하는 훅을 구현하는 것도 좋은 생각이다.

- 지금 한창 개발 중인데 그만두고 잠시 다른 일을 해야 한다면, 다음에 개발할 부분에다가 일부러 고장 난 유닛 테스트를 작성하는 것도 좋은 생각이다. [어떤 말인지 이해가 안 된다.]

- 코드를 디버깅할 때 가장 먼저 시작할 일은 버그를 짚어내는 새로운 테스트를 작성하는 것이다. 이런 일이 언제나 가능한 것은 아니지만, 이런 버그 직업이 테스트들이야말로 당신의 프로젝트에서 가장 가치 있는 코드 조각이 될 거다.

- 테스트 함수에는 길고 서술적인 이름을 사용하셔야 한다. 테스트에서의 스타일 안내서는 짧은 이름을 보다 선호하는 다른 일반적인 코드와는 조금 다르다. 테스트 함수는 절대 직접 호출되지 않기 때문이다. 실제로 돌아가는 코드에서는 `square()` 라든가 심지어 `sqr()` 조차도 괜찮다. 하지만 테스트 코드에서는 `test_square_of_number_2()`, `test_square_negative_number()` 같은 이름을 붙여야 한다. 이런 함수명들은 테스트가 실패할 때나 보인다. 그러니 반드시 가능한 한 서술적인 이름을 붙여야 한다.

- 테스트 코드의 또 다른 사용 방법은 새로운 개발자들을 위한 안내서로 쓰는 방법이다.

> 출처 https://python-guide-kr.readthedocs.io/ko/latest/writing/tests.html

## 테스트 코드를 작성해보자

최근에는 내가 주로 개발하는 언어가 이거다! 라고 말할만한 건 없다. 왜냐하면, 어떠한 개발을 하고자 할 때 그 프로젝트의 특징에 따라서 작성 코드를 변경하고 있어서 다양하게 언어를 사용하고 있다. 지금은 Python, JS, Java(Kotlin) 이 정도 사용한다.

오늘은 세 개 언어 중 Python에 대해서만 검증 코드 작성을 해보려고 한다.

Python의 테스트 라이브러리에는 밑에 처람 여섯 가지가 있다.
- Unittest
- Doctest
- pytest
- Nose
- tox
- mock

## Unittest

Unit test는 파이 썬 표준 라이브러리 중 아주 유용한 테스트 모듈이다. 테스트 코드를 직접 작성해서 사용해 본 적은 없지만, Java로 App 개발을 하면서 의존성으로 패키지로 자주 보였던 것 중에 Junia이란 게 있었는데 사용법이 비슷하다고 한다.

unittest에 포함된 주요 개념에는 다음과 같은 구조로 알 수 있다.
  - Test Case :
    - unit test 모듈의 테스트 조직의 기본 단위
  - Fixture :
    - 테스트함수의 전 또는 후에 실행
    - 테스트가 실행되기 전에 테스트 환경이 예상된 상태에 있는지 확인하는 데 사용
    - 테스트 전에 데이터베이스 테이블을 만들거나 테스트 후에 사용한 자원을 정리하는데 사용
  - Assertion :
    - unittest가 테스트가 통과하는지 또는 실패하는지를 결정.
    - bolo test, 객체의 적합성, 적절한 예외 발생 등 다양한 점검을 할 수 있음
    - assertion이 실패하면 테스트 함수가 실패합니다.

아래 코드를 한번 해석해 보겠다.

- setUp(self):
  - setUp(self)는 unittest요소 중 Fixture에 해당 된다. 그중에서 **테스트 전에 수행**되는 메소드에 해당 된다. 테스트를 할 대상에 필요한 사전 데이터를 가져오는 작업을 할 수 있다.
- tearDown(self):
  - tearDown(self)은 unittest 요소 중 Fixture에 해당하고, **테스트 후 수행**되는 방법이다. setup(self) 메소드에서 생성한 파일을 제거하는 코드를 작성할 수 있다.
- test_runs(self):
  - 실제 테스트 코드를 작성하고 실행하는 메소드이다.
- self.assertEqual(custom_function(self.file_name), 3):
  - `custom_function(self.file_name)`코드를 실행하고 결과가 3과 같으면 Test Pass라는 의미이고 assertEqual가 테스트 통과 기준점이라고 할 수 있다.
- self.assertRaises(IOError):
  - 어떠한 데이터가 들어갔을 때 어떤 Error가 도출 되는지 잡을 때 사용하는 메소드이다.

```
import unittest
import os


def custom_function(file_name):
    with open(file_name, 'rt') as f:
        return sum(1 for _ in f)


# TestCase를 작성
class CustomTests(unittest.TestCase):

    def setUp(self):
        """테스트 시작되기 전 파일 작성"""
        self.file_name = 'data.txt'
        with open(self.file_name, 'wt') as f:
            f.write("""
            Data1
            Data2
            Data3
            """.strip())

    def tearDown(self):
        """테스트 종료 후 파일 삭제 """
        try:
            os.remove(self.file_name)
        except:
            pass

    def test_runs(self):
        """단순 실행여부 판별하는 테스트 메소드"""
        custom_function(self.file_name)

    def test_line_count(self):
        self.assertEqual(custom_function(self.file_name), 3)

    def test_no_file(self):
        with self.assertRaises(IOError):
            custom_function(self.file_name)

# unittest를 실행
if __name__ == '__main__':
    unittest.main()
```
| Method | Checks that | New in |
|-|-|-|
|assertEqual(a, b) | a == b | |
|assertNotEqual(a, b) | a != b | |
|assertTrue(x) | bool(x) is True | |
|assertFalse(x) | bool(x) is False | |
|assertIs(a, b) | a is b | 3.1 |
|assertIsNot(a, b) | a is not b | 3.1 |
|assertIsNone(x) | x is None | 3.1 |
|assertIsNotNone(x) | x is not None | 3.1 |
|assertIn(a, b) | a in b | 3.1 |
|assertNotIn(a, b)|a not in b|3.1 |
|assertIsInstance(a, b) | isinstance(a, b) | 3.2 |
|assertNotIsInstance(a, b) | not isinstance(a, b) | 3.2 |
|assertRaises(exc, fun, &ast;args, &ast;&ast;kwds) | fun(&ast;args, &ast;&ast;kwds) raises exc | |
|assertRaisesRegex(exc, r, fun, &ast;args, &ast;&ast;kwds) | fun(&ast;args, &ast;&ast;kwds) raises exc and the message matches regex r | 3.1 |
|assertWarns(warn, fun, &ast;args, &ast;&ast;kwds) | fun(&ast;args, &ast;&ast;kwds) raises warn | 3.2 |
|assertWarnsRegex(warn, r, fun, &ast;args, &ast;&ast;kwds) | fun(&ast;args, &ast;&ast;kwds) raises warn and the message matches regex r | 3.2 |
|assertLogs(logger, level) | The with block logs on logger with minimum level | 3.4 |
|assertAlmostEqual(a, b) | round(a-b, 7) == 0 | |
|assertNotAlmostEqual(a, b) | round(a-b, 7) != 0 | |
|assertGreater(a, b) | a > b | 3.1 |
|assertGreaterEqual(a, b) | a >= b | 3.1 |
|assertLess(a, b) | a < b | 3.1 |
|assertLessEqual(a, b) | a <= b | 3.1 |
|assertRegex(s, r) | r.search(s) | 3.1 |
|assertNotRegex(s, r) | not r.search(s)| 3.2 |
|assertCountEqual(a, b) | a and b have the same elements in the same number, regardless of their order| 3.2 |
|assertMultiLineEqual(a, b) | strings| 3.1 |
|assertSequenceEqual(a, b) | sequences| 3.1 |
|assertListEqual(a, b) | lists| 3.1 |
|assertTupleEqual(a, b) | tuples| 3.1 |
|assertSetEqual(a, b) | sets or frozensets| 3.1 |
|assertDictEqual(a, b) | dicts | 3.1 |

## Doctest

Unittest는 예외를 포함한 전체 기능을 세밀하게 검사하는 것이라면, Doctest는 간단하게 사용 예제를 테스트하는 정도의 목적으로 쓰인다. Documentation string(docstring) 안에 포함된 python 명령을 실행하고 예상 결과를 확인함으로써 코드를 테스트 할 수 있다. 사용법이 매우 간단하고 docstring에 예상 결과 코드를 넣는 것으로 함수의 설명을 대신하는 것과 동시에 코드를 테스트할 수도 있는 장점이 있다.

Unittest와는 다른 느낌이 있다. 따로 알고 있어야 하는 개념이 존재하지 않고, 함수 자체에 대한 예상 값을 바로 보고 싶을 때 적절하다고 생각한다.

Python으로 테스트 코드를 작성은 아래와 같이 하면 된다.

```Python
def my_function(a, b):
    """Returns a * b.

    Works with numbers:

    >>> my_function(2, 3)
    6

    and strings:

    >>> my_function('a', 3)
    'aaa'
    """
    return a * b
```

실행은 `python -m doctest -v test.py` 명령어로 실행할 수 있다. -m 은 doctest를 메인 모듈로 사용한다는 의미이고 -v는 코드 실행 중에 결과를 출력해주는 옵션이다.

혹은 다음과 같이 작성을 하면 일반적으로 실행하는 코드인 `python -v test.py` 로도 실행이 가능하다.

```Python
import doctest

def my_function(a, b):
    """Returns a * b.

    Works with numbers:

    >>> my_function(2, 3)
    6

    and strings:

    >>> my_function('a', 3)
    'aaa'
    """
    return a * b

if __name__ == '__main__':

    doctest.testmod()
```

테스트만 따로 하기 위해서는 다음과 같이 코드를 작성하면 된다.

```Python
import doctest
import test_module
import test_module2

if __name__ == '__main__':
    doctest.testmod(test_module)
    doctest.testmod(test_module2)
```

그러나 이런 방식으로 코드를 작성하면 실제로 돌아가는 코드에 테스트 코드를 결합하다보니 배포를 위한 코드를 다시 작성해야하는 일이 생긴다. 실제 배포를 위해서는 다음과 같이 작성하면 된다.

```Python
// doctest_my_function.py
def my_function(a, b):
    return a * b

// doctest_in_help.rst
>>> from doctest_my_function import my_function
>>> my_function(2, 3)
6
>>> my_function('a', 3)
'aaa'

// test.py
import doctest

if __name__ == '__main__':
    doctest.testfile('doctest_in_help.rst')
```

## Pytest

`pip install pytest`

[자료1](https://twpower.github.io/15-install-pytest-and-basic-usage)

[자료2](https://wkdtjsgur100.github.io/pytest-description-1/)

## Nose

`pip install nose`

[자료1](https://helloh.tistory.com/20?category=114286)

nose로 모듈을 테스트 할 때 모듈과 함수의 이름이 중요하다. nose가 실행되면 test_로 시작하는 파일 이름을 찾는다.


## tox

`pip install tox`

[자료1](http://corecode.pe.kr/2018/01/18/python_tox/)

Tox를 실행하려면, tox.ini와 setup.py가 필요하다.
```Python
// setup.py

from setuptools import setup
setup(name='hello_flask',
      version='0.1')
```

```
// tox.ini
[tox]
envlist=py27,py36
[testenv]
deps=flask
     pytest
commands=pytest
```

위와 같이, envlist에 파이썬 버전, deps에 의존성, commands에 테스트 명령을 적어준다. envlist에 기술한 파이썬 버전 2.7과 3.6은 시스템에 미리 설치해둬야 한다.

## mock

[자료1](https://jupiny.com/2016/10/07/test-requests-connection-error-using-mock/)

## Test Case ([이론](https://m.blog.naver.com/PostView.nhn?blogId=wisestone2007&logNo=221064272586&proxyReferer=https%3A%2F%2Fwww.google.com%2F))

## 출처

[파이썬 위키독스](https://wikidocs.net/16107)

[파이썬을 여행하는 히치하이커](https://python-guide-kr.readthedocs.io/ko/latest/writing/tests.html)

[Unittest 모듈 자료](https://suwoni-codelab.com/python%20%EA%B8%B0%EB%B3%B8/2018/03/15/Python-Basic-unittest/)

[Doctest 모듈 자료](https://cjh5414.github.io/python-doctest/)

[Pytest 모듈 자료1](https://twpower.github.io/15-install-pytest-and-basic-usage)

[Pytest 모듈 자료2](https://wkdtjsgur100.github.io/pytest-description-1/)

[Nose 모듈 자료](https://helloh.tistory.com/20?category=114286)

[Mock 모듈 자료](https://jupiny.com/2016/10/07/test-requests-connection-error-using-mock/)
